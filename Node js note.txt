

****************************************  NODE   JS  TUTORIALS  [  Basic to  Advance ] *****************************************

***************************************************** Introduction to NODE JS ***************************************************

 ****** What is Node.js ::::  is an open source , cross-platform JS  runtime environment.
 
                                             Not a  language and not a Framework .

                                          *** Open source :::  Source code is publicly available for sharing and modification.
                                          *** Cross platform ::: Available on Mac , Windows and Linux etc .
                                          *** JS Runtime Environment ::: Environment provides all the necessary components in order to use 
                                                                                             and run JavaScript program  From OUTSIDE  THE  BROWSER.


 ****** Why learn Node.js :::: 
                                               1 . Build end-to-end application by learning one language.
                                               2 . Number of major companies like linked-in pay pal, Netflix migrates their backend to Node.js.
                                              3 . Offers mostly in Node.js in Backend by most of the companies now.
                                              4. Huge community support.
 
         To  create  a  full stack application we have to learn a Node framework for the web EXPRESS . JS  based on Node.js .


********************************************** ECMA SCRIPTS *******************************************************************

  ***** History of  First ever Browser :::: 

              In 1993 , the first user Interface feature came up with the browser named MOSAIC .
              In 1994 , the lead developers of MOSAIC founded a company named NETSCAP and released more polished browser
                             named NETSCAP NAVIGATOR.

             In 1995 , NETSCAPE created a new scripting language called JavaScript [ This was only for marketing purposes.]

       At the same year [ 1995 ] , Microsoft debuted their first browser named INTERNET EXPLORER.

                     and In 1996 , Microsoft launch their first scripting language named Jscript.

               SO  The differences between these two scripting language created ambiguty among the developers.

 ****** ECMA  INTERNATIONAL :::: 

           In Nov 1996 , Netscape submitted their JavaScript to ECMA  INTERNATIONAL demanding a standard specification that

                                 would help other implementation consistent across browsers.

           In case of  JavaScript , the standard is called ECMA - 262 [ Language Specification]  and the committee works on that             named TECHNICAL COMMITTEE [ TC 39 ]

          Then  ECMA  declared the language as  ECMAScript . [ Because ORACLE owns their microsystems having the name of 
                                                                                                       JavaScript ]

          JavaScript is basically ECMAScript at its core but builds on top of that . 


********************************************* CHROME'S  V8  ENGINE ***********************************************************

               JavaScript Code  >>>   Transformed Machine Code By  JavaScript Engine  Developed by Web browser vendors.

               Popular JavaScript Engines are :::  
                         
                                   V8 -  Google Chrome ,  SpiderMonkey - Mozilla FireFox , JavaScriptCore - Safari , Chakra - IE.

       **** Some Important Informations about V8 Engine :::: 

                     V8 is Google's open source JavaScript engine.

                     V8 implements ECMAScript as specified in ECMA-262.

                     V8 is written in C++ and is used in Google Chrome, the open source browser from Google.

                     V8 can run standalone, or can be embedded into any C++ application. 

                    [As we know that c++ is better to handle file, db connections and network operations. By embedding V8 It will                      allow to use all  JavaScript Features .  ]

               Node.js  is  written in  C++  as well.
                      
                                                                                                                                       
************************************************* JAVASCRIPT  RUNTIME ********************************************************

        ***** JavaScript Engine ::: Every browser has a JavaScript engine. It is one component in JavaScript runtime.
   
         ****  Let's take a look in Google Chrome ::: 

               1 . V8 Engine  >> 2. Web Api / Browser Api  >> 3.[ Microstack Queue / Call Back Queue ] >> Event loop >> V8 Engine
 
                 [ Memory + Call Stack in V8 engine >>  Connected to Event loop ]                                                                                                                                    
              2. Web API / Browser API  >> consists of Dom , Storage , Timers [ setIntervals , setTimeout ,promises, storages ] . They 
                                                             are the part of JS Engines but not the part of JavaScript language itself. All API's are 
                                                             provided by the browser.

             3. Microstack Queue / Call Back Queue ::: To handle the Asynchronuous Tasks.

             4. Event loop ::: Ensures the async tasks are completed in right order.


***************************************  DETAIL  EXPLANATION  ABOUT  NODE.JS ********************************************

   ***** What can you build with a Node.js :::: 

              Before Introducing Node.js in 2009 , JS could be run only in browser . 

           1 . Can run JS  program outside the browser . 

           2 . Traditional websites.

           3 . Backend services like APIs.

          4 . Real-time applications and can build powerfull and complex application . 

          5 . Streaming Applcations . [ Netflix ]

          6 . Streaming Services . 

          7 . CLI tools.

          8 . Multiplayer games . 


    ***** Some  Node.js  Components in Code :::: 

              1 . JS Lib >> Can internally call the C++ features so that user can use them through JS code.

              2 . Src >> As  We know JS is not designed for doing low level design like file system or networking etc. On the other                               
                             hand  C++ is designed for these tasks . 

               1 . Dependencies >>  V8 [ The engine of google ]
                                                 uv  [ open Source library called LIBUV providing Node.js access to file system and networking. ]

                     
             ****** NODE .JS  does not have access to the web API . That means there is no window object or document will work

                        on Node.js.

            ****** Node.js can execute not only the ECMAScript language but also new features that are made available through 

                      C++ bindings using the V8 engines.

           ****** Consists of C++ files which forms core features and JS files which expose common utilities and some of the C++

                     features for easier consumption.


************************************************* NODE .JS  [ Start with Coding ] ************************************************

   ******** Executing JS with  NODE . JS :::: 

               1 . Node REPL ::: [ Read  Evaluate  Print  Loop ] =  REPL  read the JS code >> Evaluate them and throw the output

                                            untill user exit from the program . IT is  StraightForward and Direct  method to execute JS app.

                   In the  TERMINAL :::

                    > node 
                    >console.log(' Hello World ')
                    >Hello world
                    >undefined [ Return the upper function ]
                    .....

              2 . Executing code in a JS File in the command Line .  Mostly used and preferred way.

                    > node  index.js [  Create a JS app file and run the file in powershell , cmd or git bash ]


******************************************** BROWSER  vs  NODE . JS ***********************************************************


     ****** Key  Differences between Browser and Node.js :::: 

                  1 . In Browser , most of the time Interacting with  DOM , Web API like Cookies etc.

                      But  In  Node.js , we don't have DOM , window or all other Objects  that are provided by the browser.

                 2 . [ primary difference ] :::: In Browser , don't have all nice APIs that NODE.JS provides through its Modules.

                                                               Example :: The File System Access functionality . 


                 3 . Environment Control :::: In Node . js , can control the environments . That means dependeing on the Node 

                                                                                    version can use all the modern ES features as well .

                                                              In Browser , are at the mercy of what users choose . 

                                                              SO  We should always keep in mind where we want to execute our code.
 
                                                                     That means JS with Node.js or JS for Browser.



**************************************************** NODE . JS  Features *********************************************************


******************************************************  MODULES ***************************************************************

    ****** Modules ::::  an encapsulated and reusable chunk of code that has its own context . In Node.js , Each file is treated 

                                   as a  seperate module.

                   ***** Three types of Modules :::: 

                                          1 . Local Module :::: Modules that we create in our application.

                                         2 . Built-in-module :::: Modules that Node.js ships with out of the box.

                                         3 . Third-party-module :::: Modules that are developed by others can use in our application . 



*********************************************** LOCAL MODULES ***************************************************************

   ******* Definition ::::  Modules that we create in our application.

         ***** CommonJS :::: is a standard that states how a module should be structured and shared.

                     ***** NODE . JS  adopted the CommonJS when it started out . Each file is a module that is isolated by default.

                  Example ::::  

                  Create  an  add.js file :::: const add=(a,b)=>{
                                                                       return a+b
                                                                           }
                                                                const sum=add(2,5)
                                                                console.log(sum)


                 IF  We want to load and execute it from index.js then ::::: 

                                       require('./add.js')  [  Require function load the add.js file in index.js file and execute it ]
                                       console.log('Hello world from index.js')

                   Debugging will demonstrate how Node.js execution flow works .


*****************************************************  MODULE  EXPORTS ******************************************************


         ***** To make the code private to the users and Reusable We can export the functions or variable by 

                  MODULE . EXPORTS   Objects .

                  For example :::: In add.js ::: 
                                             const addition=(a,b)=>{  [  Can give any name of exported item ]
                                                            return a+b
                                                          }
                                               module.exports=add  [  Here export the function and make available for other modules ]


                    In  index.js ::::: 

                       const add=require('./add')                        [  Take the exported item from that loaded file ]
                       console.log('Hello world from index.js')
                       const sum=addition(2,5)                                    [  Invoke the function and save it to sum variable ]
                       console.log(sum)


************************************************ MODULE SCOPE ****************************************************************

       Each  Module has its own SCOPE . That means no matter the variable or function name is same or not they will execute

         independently . NODE . JS acheives that By  IIFE [ Immediately Invoking function expression ]. That means each 
         MODULE is considered as IIFE . 

         For Example :::: 

                   In iife.js ::::     [  Here  each function is considered as an independent MODULE and has its own SCOPE  ]

                                      (function (){
                                            const superHero='batman'
                                            console.log(superHero)
                                       })();
                                    (function (){
                                           const superHero='superman'
                                           console.log(superHero)
                                          })()

           SO Before a module is executed NODE . JS will wrap it with a function wrapper [ IIFE ] that provides module scope and 
           save from conflicting variables or functions. There is proper encapsulation and unaffected variables.

            For example ::::  Create two individual module named batman and superman .

                       In  batman.js ::: 
                                                   const superHero='batman'
                                                   console.log(superHero)

                       In superman.js ::: 

                                                    const superHero='superman'
                                                    console.log(superHero)

                     Both of them  holds the value in a same named variable superHero . But there SCOPE is different.

                    Now IN index.js :::

                                                require('./batman')
                                                require('./superman')

                        TERMINAL  output ::: 
                                                              batman
                                                              superman 
                                                             

*************************************************** MODULE WRAPPER *********************************************************

    The  IIFE  that wraps every modules contains 5 Parameters which are pretty important for the functioning of a module.

                          They are :::  Exports ,Require,  Module , __filename , __dirname .

      In our created IIFE  ::::   Take an argument and after Invoking >>>

                                                    (function (message){   [  Take a parameter and argument will come from the bottom ]
                                                             const superHero='batman'
                                                              console.log(message, superHero)
                                                         })('Hello');
                                                   (function (message){
                                                              const superHero='superman'
                                                              console.log(message, superHero)
                                                       })('Look');
     

     ***** Now  how IIFE  Works for MODULE ::::  

                 For example let's take our  batman.js file :::::  Behind the Scene each MODULE  bind by IIFE.

                           ( function (exports, require, module , __filename , __dirname){ 
                                               
                                            const superHero='batman'
                                            console.log(message, superHero)
                                     } )

              IN  DEBUGGING  The function is invoked with this Parameters running behind the LOCAL  sections in VARIABLES.


****************************************************** MODULE  CACHING ******************************************************

   
   *****Create a Class in  super-hero.js file ::::: 

                class SuperHero{
                           constructor(name){
                                         this.name=name
                                     }
                             getName(){
                                         return this.name
                                    }
                             setName(name){
                                         this.name=name
                                    }
                                }
                         module.exports=new SuperHero('Batman')  [  Here  export an Object of that class ]

     ******** Now in Index.js File ::::: 

                const superHero=require('./super-hero')  [  Import the object which one created in the super-hero file ]
                console.log(superHero.getName())
                superHero.setName('Superman')             [ Here we change the name by setName ]
                console.log(superHero.getName())

               const newSuperHero=require('./super-hero')
               console.log(newSuperHero.getName())          [ We will get the same value of the previous one because it is cashed 

                                                                                           consequently  It is called MODULE CASHING ]

               NODE .JS  Reuses the Cache instead of creating a new Object .


              BUT  If We want Object with different properties then we have to export the whole Class Instead of  exporting 

               a single instance . 

               In  super-hero class :::::  

                          .......  all are similiar to the previous one 

                          module.exports= SuperHero ; 

                 Now in index.js File :::: 

                    const SuperHero=require('./super-hero')   [  Import the Class and save in SuperHero variable ]
                    const Batman=new SuperHero('batman')

                    console.log(Batman.getName())

                   const Krrish=new SuperHero('krrish')
                   console.log(Krrish.getName())

                    const newSuperHero=new SuperHero('Superman')
                   console.log(newSuperHero.getName())


***************************************** IMPORT EXPORT PATTERNS OF MODULES*******************************************

    In  math.js File ::::  

                     1 . First pattern of exporting ::::: 

                            const add=(a,b)=>{
                                          return a+b 
                                       }
                             module.exports=add

                     2 . Second Pattern of Exporting ::::: 

                            module.exports=(a,b)=>{  [ Directly  Export the function without initializing into other variable ]
                                           return a+b 
                                       }

                    3 . For more than one functions or variable ::::: 

                            const add=(a,b)=>{
                                            return a+b 
                                      }
                            const subtract=(a,b)=>{
                                           return a-b 
                                      }
                            module.exports={    [  As it exports just like an object so we have to export them with an Object ]
                                     add,
                                     subtract,
                                  }

                   4 . Assign directly in export.modules object :::: 

                          module.exports.add=(a,b)=>{            [  Add property  named after add and subtract ]
                                                 return a+b 
                                           }
                          module.exports.subtract=(a,b)=>{
                                                 return a-b 
                                          } 

                  5 . Assign directly in exports object instead of using module.exports Object :::: 

                          exports.add=(a,b)=>{     [  Because Exports holds the module ]
                                        return a+b 
                                        }
                         exports.subtract=(a,b)=>{
                                         return a-b 
                                       }


     Now In index.js File :::: 

              ***** 1 & 2 the method will work as given below::::  
                   
                       const add=require('./math')
                       console.log(add(5,6))

              ****** For 3rd & 4th & 5th pattern ::::: 

                        const math=require('./math')   [  Return an Object  which will contain the methods or variables ]
                        console.log(math.add(5,6))
                        console.log(math.subtract(5,3))


************************************************** MODULE EXPORTS vs EXPORTS *********************************************

         It is recommended to  use Module.exports  over  Exports .

       As we know that Object is a mutable component So we get the following results as per our program ::: 

       In object-reference.js file ::::: 

            const obj1={
                                 name:'shobuj'
                             }
            const obj2=obj1
           obj2.name='Ahtasham'
           console.log(obj1.name)  [  The Output will be Ahtasham for both the object property name as we used Object Literal the

                                                       obj1 into obj2 ]

        But if we do it by object paranthese then ::::  

           const obj1={
                                name:'shobuj'
                             }
             let obj2=obj1              [  Now the obj2 will not mutate the obj1 ]
             obj2={
                         name:'Ahtasham'
                      }
              console.log(obj1.name)
        
        In  math.js File ::::  

                 const add=(a,b)=>{
                                            return a+b 
                                      }
                 const subtract=(a,b)=>{
                                           return a-b 
                                      }
              
                exports = {  add , subtract  }  [  IT will throw an error because exports is an reference of module.exports . So if we 

                                                                    want to assign object like this it will break the reference ]

               If we do this  in the Debugger  the  exports : {  add , subtract } will populated BUT 

                                                                         module : > exports : { empty } will not populated .

                                         [  Because the ref  was lost Because  assign an object in exports instead of attaching properties ]

               *******  Attaching properties in the existing exports be like ::::  

                              
                                      exports.add=(a,b)=>{
                                                           return a+b 
                                                         }
                                     exports.subtract=(a,b)=>{
                                                           return a-b 
                                                       }

                         BUT  Still it is recommended to use module.exports. 


*************************************************** ES  MODULES ***************************************************************

    ***** According to CommonJS ::::  Explicitly tell the module system which part of the code should be exported via  

                                                             module.exports or exports .

                                                            NODE . JS  14  or above versions support the ES Modules .

                                                       And  to IMPORT  code into a file , use the require ( )  function . 

    ***** ES  Modules is another import exporting  module system .

         ***** WHY  We need ES MODULES ::::: 

                       At the time Node.js is created , no built-in module system in JS.

                      Then  Node.js defaulted CommonJS as its module system.

               But  As of  ES2015  JS does have a standardized module system as part of the language itself.

              That module system is Known AS EcmaScript Modules or ES Modules or ESM 

          ********* How to use ES Module in Node.js :::::  

               Create a File named math.mjs ::::  [  The extension be .mjs ]

             ****** For DEFAULT  Exports :::::

               1 .  For a single variable or function :::::  
                         
                   In  math.mjs :::::  
                         
                            const add=(a,b)=>{
                                                  return a+b
                                               }
                              export default add

                                  ////  OR  //// 

                             export  default  ( a, b )=>{

                                                        return a+b 

                                                 }  

                   2 .  For two or more than two variables or functions ::::: 

                            In math.mjs ::::: 

                                     const add= (a,b)=>{
                                                      return a+b
                                                    }
                                     const subtract=(a,b)=>{
                                                      return a-b
                                                    }
                                     export default {                  [  Export  the functions in a default Object  ]
                                                     add,
                                                     subtract
                                                 }

                  ****** For  NAMED Exports ::::: 

                      ***** Export function or variable in math.js ::::: 

                             export const add= (a,b)=>{
                                            return a+b
                                          }
                            export const subtract=(a,b)=>{
                                            return a-b
                                         }

                           

                 ******Create another file named main.mjs :::::: 
            
                    ********* For DEFAULT  Exports ::::: 

                       ***** Import a  single variable or  function :::::     
                              
                                import add from './math.mjs'    [  Imported  the exported item from math.mjs file ]
                                console.log(add(5,6))

                       ***** Import  more than two or more functions :::::: 

                                import math from './math.mjs'   [  Imported the default object containing the functions or variables ]
                                console.log(math.add(5,6))
                                console.log(math.subtract(6,2))

                                /// OR /// 

                               Destructuring the Object before using them >>>

                               import math from './math.mjs'
                              
                               const { add , subtract } = math
                              
                               console.log(add(5,6))
                               console.log(subtract(6,2))


                     ******* For  NAMED  Import :::::: 

                        ***** Import all of them in a object :::: 

                                    import * as math from './math.mjs'   [  Import all functions and stored in math object ]

                                    const {add,subtract}=math      [  Destructure the math object by the function name ]
                                    console.log(add(5,6))
                                    console.log(subtract(6,2))

                      ****** Import  destructuring them on the top by their name ::::: 

                                 import  { add , subtract }  from './math.mjs'

                                 console.log(add(5,6))
                                 console.log(subtract(6,2))



********************************************** IMPORTING JSON and WATCH MODE *******************************************


        JSON  is a data interchange format commonly used with web servers. JSON data is similiar to JS Object but the key is 

         also wrapped with code .

      ****** How importing JSON file works as module in Node.js ::::: 

                  Create a  JSON  File   data.json ::::: 

                                 {
                                       "name":"Ahtashamul-Islam",
                                        "address":{
                                                    "street":"kamal Khan",
                                                     "city":"Dhaka"
                                                    }
                                  }


                IN  index.js  File :::::  

                       const data=require('./data')    [  Here  the require function will parse the data.json into a JS Object ]
                       console.log(data)
                      console.log( data.name ) >> Output the value of name property. 

  

            *******  WATCH  Mode in NODE. JS :::::  It will ensure a feature that whenever update the file it will automatically 

                                                                                changed after saving the file.

                     TO Enable watch mode terminal Command line is ::::: 

                      > node --watch  file_name 


************************************************** BUILT IN  MODULES *********************************************************

     Modules that  NODE . JS Ships with and also referred to as core modules . Available when installed NODE . JS .

    WE Have to IMPORT it before we can use it . 

    Mostly used modules are :::::  PATH , EVENTS , FS , STREAM , HTTP .          


************************************************** PATH  MODULE **************************************************************

       PATH  Module  provides utilities for working with file and directory paths. Contains 14 different properties and methods .

       ****** Import and working with a Built-in Module :::::: 

               IN  Index.js file ::::: 

                       const path = require ( ' node : path ' )               [  node :  means it is a built in module ]

                       console.log( __filename ) >>> ../..../.../../ folder / filename..

                       console.log( __dirname ) >>> ../..../..../.../folder  [ Directory of the file ]

           *****To know the base file and folder in which operation is running :::::: 

                       console.log ( path.basename ( __filename ) )  >>> index.js
                       console.log ( path.basename ( __dirname ) )  >>>  Node.js  [ Basic to Advance ]

             ****** To know the extension of file and folder ::::::: 

                      console.log( path.extname ( __filename ) )  >>> .js 
                      console.log( path.extname ( __dirname ) )  >>>  empty [  the folder has no extension ]

         ***** To return an OBJECT  by  using PARSE  Method having some significant properties :::::: 

                console.log ( path.parse ( __filename ) ) >>>  

                                                                                          {  root : 'c : //' , 
                                                                                             dir : ' C : // ..//../../.. / foldername ',
                                                                                             base : ' index .js ' ,
                                                                                             ext : ' .js ',
                                                                                             name : ' index ' 
                                                                                           } 

          ***** To find the path in a STRING Format  path.format have to use ::::: 

                console.log(path.format(path.parse(__filename)))  >>>> Output will be 

                  C : // users /.../../../../folder_name / index.js  [  It is in the STRING format ]

         ******  Determine the PATH  is Absolute or not by  isAbsolute method :::: 

                     console.log(path.isAbsolute(__filename)) [  Return true as it is the built in module path or Absolute path ]
                     
                     console.log(path.isAbsolute('./data.json'))  [  Return  false as it addresses  ' ./ ' which is a Relative path ]

           
        ******  About  JOIN  Method :::::  
                                                                it joins path segments together  using platform specific seperator  as delemeter and 

                   then normalize the resulting path .

                  console.log(path.join('folder1','folder2','index.html'))  [  folder1 / folder2 / index.html ] 
                 
                  console.log(path.join('/folder1','folder2','index.html'))  [ /folder1 / folder2 / index.html ]  [ simple concatenation ]

                  console.log(path.join('folder1','//folder2','index.html'))   [ folder1 / folder2 / index.html ] [ Eliminate the extra / ]

                 console.log(path.join('folder1','folder2','../index.html'))   [  folder1 / index.html ] [ ../ skip one step ] 

               
               ****** Finding the path of a specific file ::::::  JUST  Join  __dirname with the file .

                         console.log ( path.join ( __dirname , ' data.json ' )  

                  >>> Output be :::  C : \ users \...\...\...\...\...\data.json 

             ****** Build a  complete path with  RESOLVE method :::::: 

                       const path = require('node:path')

              // OR  const path = require ( 'path ' ) [  It will work same as before ]

                      console.log(path.resolve('folder1','folder2','index.html'))
               
             [   users / .../ .../ ... /.../ folder1 / folder2 / index.html >>> If there is no / at starting then it will add the absolute path

                                                                                                            at the beginning ]       

                  console.log(path.resolve('/folder1','folder2','index.html'))

              [  C :: / folder1 / folder2 / index.html  >>>>  There is a forward slash that's why the path will begin from given args ]

               console.log(path.resolve('/folder1','//folder2','index.html'))

              [  C :: / folder2 / index.html  >>> Where the last ' / ' found the path will begin from there ]

               console.log(path.resolve('/folder1','//folder2','../index.html'))

             [  C :: / index.html >>>  It will skip all the previou directory when given a jump to another folder directory  ]

              console.log(path.resolve('folder1','/folder2','index.html')) 

             [  Same as no 3  case .......... ]

               console.log(path.resolve(__dirname,'data.json'))

            [  Similiar  as  join method in previously discussed ....... ]


            ******* To specify  node : protocol before using any built-in module there are some benefits :::::::  

                 1 . Makes it perfectly clear that import is Node.js built-in module .

                2 . Makes the import identifier a valid absolute URL .

                3 . Avoids conflicts for future Node.js built-in modules .
 

************************************************ CALLBACK  PATTERNS *********************************************************

  As  WE know  :::::  In JS  functions are considered as first class object .  

                                A function can be passed as an argument to a function and 
 
                                A functiuon can also be returned as values from other functions .

      
         ****** Lets take an Example ::::: 

                        function greet(name){                 [   It is  a CALL Back function which can be passed as an argument ]
                           console.log(`Hello ${name}`)
                          }

                       function greetFinal(greetfn,name){   [  HIGHER  Order function which takes a function as an argument ]
                                      greetfn(name)               
                                  }

                       greetFinal(greet,'Ahtashamul Islam')    [  Here  greet( ) is considered as a callback function and pass as an                                                                                            argument ]

                     

       ****** Types of CALL BACK  function :::::  

                      1 . Synchronous  Call Back 

                      2 . Asynchronous Call Back

                  *****  Synchronous CALL BACK :::::  Call back which is executed immediately is called Synchronous Call back.

                                For example :::::  let numbers =[ 1 , 2 , 4 , 5 , 6 , 7 , 8 ]
                                                                numbers.sort ( ( a , b ) => a-b )    [  Call back func as an argument ]
                                                                numbers.filter( a=>a%2) 

                  ***** Asynchronous CALL BACK :::::  is used to continue or resume code execution after an asynchronous operation

                                                                                has completed. That means Call backs are used to delay the execution of a 

                                                                                function untill a particular time or event has occured.

                         *****  AS  We Know that NODE.JS  have an asynchronous nature to prevent blocking of execution.

                                    For example ::  Reading data from a file , fetching data from a database or handling a network request.

                       ****** Asynchronous callback in BROWSER ::::: 

                                   function callback ( ) { 
                                                              document.getElementById( ' demo ' ).innerHTML= 'Hello World ' 
                                                            }
                                      document.getElementById(' btn ' ) . addEventListener ( ' click ' , callback )

                                 [  Here  the callback function is executed after the event click is occured ]


**************************************************** EVENTS MODULE **********************************************************

          EVENTS Module is  a built in module in NODE . JS .  EVENTS Module allows us to work with events in NODE .JS .

          [  An Event is an occurrence or an action that has happend in our app that we can respond to . ] 

         ****  Using the Events module , we can dispatch our own custom events and respond to this custom events in a  non 
                 blocking manner .

          ******* EVENTS  Module Scenarios :::: 

                     const EventEmitter=require('node:events')   [  RETURN  A  Class  which will EMIT and ON funtions for Occurring
                                                                                                   and Responding events ON ]
                    const emitter = new EventEmitter()

                   emitter.on('order-pizza',(size,topping)=>{      [ Arg 1 : EVENT  ,  ( Arg 2 , Arg 3 ... are Call back args from EMIT ]
                                console.log(`Order of a ${size} and ${topping} pizza is being placed and baking is going on`)
                               })

                      emitter.on('order-pizza',(size)=>{
                             if(size=='large'){
                             console.log('Drinks is complementary !')
                             }
                        })
                  console.log('Events are not occured yet.')
                 
                 emitter.emit('order-pizza','large','mushroom')    [  THE UPPER  ON will execute when the emit function is Called ]

                     [  in  EMIT  >>> first argument is EVENT name and Others are the Call back function's arguments is ON ]

              
               ******** BUILDING  Our  Own Module which will be on top of EventEmitter :::: 

                       Let's create a new file named pizza-shop.js having it's own properties and methods and inherit EventEmitter ::::: 

                             const EventEmitter = require('node:events')


                                class PizzaShop extends EventEmitter{     [  Here we inherit the EventEmitter class ]
                                    constructor(){
                                    super()
                                    this.orderNumber=0
                                    }
                                  order(size,topping){
                                      this.orderNumber++;
                                      this.emit("order",size,topping);            [  Here  call the emit method from  EventEmitter and pass the rest
                                   }
                                 displayOrderNumber(){                                    of the arguments from calling order( ) method externally ]
                                     console.log(`Current order number is ${this.orderNumber}`)
                                   }
                                }
                                 module.exports=PizzaShop
                                 module.exports=PizzaShop   [  Exports the PizzaShop class in order to use other module ]

                 ****** Taking another file named drinks-machine.js :::::: 

                             class DrinkMachine{
                                        serveDrink(size){
                                            if(size=='large')
                                                  console.log(`Drink is complementary`)
                                             }
                                       }
                              module.exports=DrinkMachine  


                   ******* Now in index.js file ::::: 

                                const PizzaShop=require('./pizza-shop.js')
                                const DrinkMachine=require('./drink-machine.js')

                               const drinkMachine=new DrinkMachine()

                               const pizzaShop=new PizzaShop()

                              pizzaShop.on("order", (size,topping)=>{
                                        console.log(`Order of a ${size} and ${topping} pizza is being placed and baking is going on`)
                                        
                                          drinkMachine.serveDrink(size)      [  We call the method of drinkMachine object ]
                                    })
                           
                             pizzaShop.order("large","mushroom")  [  Here We pass the size and topping whih will pass through the emit fn ]
                             pizzaShop.displayOrderNumber()


   *****  pizzaShop.order( 'large' , 'mushroom ' ) >>> emit( ' order ' , ' large ' , ' mushroom ' ) >> on ( ' order ' , ( size , topping) =>{ })
                                                                                      [ take the args value from order( ) ]              [ Respond the event ]

  

         AS  We can see using events we are able to tie together different modules without having to tightly coupled them .

        And  PizzaShop can extend Module EventEmitter allowing them emit and react their own custom event .


********************************************* CHARACTER SETS  and ENCODING ***************************************************

         ****** Character in Binary Format :::: 

                      First converted to a Number and then Convert into Binary Number .

                    In Browser Console :::::  

                                                       >   'V'.charCodeAt()
                                                       >  86 [ is the Numeric representation of  Character V ]
                                           [  Browser use the Unicode Character sets ]

         ******* Character Sets ::::: 

                       Character  Sets are predefined lists of Characters represented by Numbers .

                       Two Popular character sets are  >>>>  Unicode  and  ASCII .

         ******* Character  Encoding  ::::: 

                       How to represent a number in a character set as binary data before it can be stored in a computer.

                      Shortly ::::: How many bits to use to represent the number .

                      Popular Character ENCODING System is  UTF-8 which states that character should be Encoded in Bytes [ 8 bits ]

                     So  EIGHT  1's or 0's should be used to represent the code of any character in binary .

                     Example ::::  4 => 100 [ binary ] => 00000100 [ UTF - 8 Encoding ]

                                          V => 86 => 01010110  

 
 **************************************************** STREAMS  and BUFFERS *******************************************************

        ***** STREAM ::::::  is a Sequence of Data that is being moved from one point to another over time .

                                     Example :::: A stream of  data over the internet being moved from one computer to another.

                                                 // OR  >> Stream of data being transferred from one file to another within the same computer.

                And  Process Streams of data in Chunks as they arrive instead of waiting for the entire data to be available before 

                Processing .

                Ex ::::  Watching video on YOU TUBE  , Transferring file A to file B 

               **** Advantage of streaming ::::  Prevents unnecessary  data downloads and memory usage . 

      
       ****** BUFFER  ::::::  Memory where Data wait temporarily is nothing but the buffer . 

                                         NODE .JS can not control the pace at which data arrives in the stream . 

                                         NODE . JS can only decide when is the right time to send the data for processing . So if there is data 

                                          already processed or too little data to process , NODE . JS puts the arriving data in a buffer . 

                                         Buffer is a small area that NODE . JS maintains in the runtime to process a stream of data . 

                     Ex ::::  Streaming a Video online .

                                If the connection is fast enough , the stream will be fast enough to fill up the buffer and send it out for                                 processing . 

                                That will repeat till the stream is finished. 

                                But in case of slow connection , after processing the first chunk of data that arrived , the video player will 
                                display a loading spinner which indicates it is waiting for more data to arrive.

                               While the video is playing , more data will continue to arrive and wait in the buffer . 

                       ***** NODE .JS  Provides  BUFFER feature globally .

                              IN INDEX . JS :::::: 

                                       const buffer=new Buffer.from('Ahtasham')

                                       console.log(buffer)   >>>  < Buffer  41 68 73 61 74 68 61 6d > [  Here the CHARACTER is encoded to HEX ]

                                       console.log(buffer.toJSON())  >>>> The Output will be :::: 

                                                                                                 {  type : ' Buffer ' , data : [ 65 , 104 , 116 , 97 , 115 , 104 , 97 , 109 ] }

                                                                                                                           [  Here UNICODE Character sets used to represent

                                                                                                                                the characters to NUMBERS ]

                                      console.log ( buffer.toString( ) ) >>> WIll output the string  '  Ahtasham ' .

                         ****** WRITING in the Buffer :::: 

                                      buffer.write('shobuj')  >>> Write into the exixting buffer string .
                                     
                                      console.log(buffer.toString())   >>>  shobujam [  As buffer has a limited memory so it will replace the 

                                                                                                                     existing characters with the new one from the start ]

                               IF THE Entry is bigger than the previous value STRING :::: 

                                     buffer.write ( ' Shobujboss' ) 

                                    console.log( buffer.toString( ) ) >>> Shobujb  [  Because when the buffer was created it was allocated fixed

                                                                                                                   8 bits Memory for ' Ahtasham ' . That's why first 8 bits 

                                                                                                                 were stored and the last 2 bits are discard from the memory ]

              
*******************************************  ASYNCHRONOUS  JAVASCRIPT *********************************************************

            *******  As  We  know JS is synchronuous , blocking and single-threaded language . 

                         1 . Synchronous :::::  Code executes from top to down , only one line executing at any given time.

                         2 . Blocking ::::::  The subsequent process won't kick off untill the former is completed .

                         3 . Single-thread :::::: Is a process that JS program can use to run a task . Each thread can only do one task at a 

                                                            time . JS has only one thread named main thread for executing any code . 

            ******** To help doing this Asynchronous tasks we have :::::  

                            1 . For  FRONT ENDERS  BROWSERS come to help 

                            2 . For  BACKEND NODE. JS Comes to help .

                            That means BROWSERS and NODE . JS define functions and API's that allow us to register functions that 

                            should not be executed Synchronously and should instead be invoked Asynchronously when some kind of 

                           Events occured . [  That means these tools provides non-blocking Asynchronous behaviors ]

                            That would be a passage of time ( setTimeout / setInterval ) , user Interaction with Mouse ( addEventListener )

                            or data being read from a file system or the arrival of data over the network ( callback , promises , async-await )

                            This will allow doing several things at the same time without blocking or interrupting the main thread.


*********************************** FS [ File System ]  BUILT - IN MODULE *********************************************************

              ***** Main task is to give allowance to work with File System on our Computer .

                   ****** READ Contents into a File :::::: 

                     Ex ::::  IN Index.js :::  

                                   const fs=require('node:fs')       [  Return an Object  Containing Methods and Properties ]

                                   const fileContent=fs.readFileSync('./file.txt','utf-8') 

                    [  readFileSync( ) is synchronous way of reading a file . JS engine holds the program untill the file contents  are read

                before moving on to the next step . ]
              
                          [  Takes two parameter  one is the File path and  Encoding character style ]
                                             [  FS Module internally uses the BUFFER ]

                                  console.log(fileContent)


                  ***** But if we do this using readFile ( ) method ::::: 

                           const fs=require('node:fs')

                          console.log('First')
                          const fileContent=fs.readFileSync('./file.txt','utf-8');
                          console.log(fileContent)
                          console.log('Second')
                          fs.readFile('./file.txt','utf-8',(error,data)=>{        [   Take a callback function having two arguments one is error and 
                                       if(error){                                                         another is data ]
                                             console.log(error)
                                       }else{
                                             console.log(data)
                                          }
                                    })
                         console.log('Third')

                   THE  OUTPUT BE :::: 

                                          First
                                          Hello Viewers ! Welcome to the session of NODE . JS
                                          Second
                                         Third
                                          Hello Viewers ! Welcome to the session of NODE . JS

                     HERE  We see that the Third is printed first then the file Content printed. Because  NODE . JS does not hold 

                   or  BLOCK the program and keep a Track of that method taking a little amount of time to print it . But it will 

                  allow the next line to be executed . SO readFile( ) is operated Asynchronously by NODE . JS .

              ******** WRITE  Contents into a FILE ::::: 

                      const fs = require ( ' node : fs ' )

                      fs.writeFileSync('./greet.txt','Welcome to Node.js')   [  Create a File named greet.txt and content is the 2nd Argument]

                      fs.writeFile('./greet.txt','Hello Ahtasham',(err)=>{    [  If the path is same then Override the content with the previous
                              if(err){                                                                       contents ]
                                console.log(err)
                              }else{
                               console.log('File Written')
                             }
                       })    


                    ****** APPENDING  With Existing Content ::::: 

                       fs.writeFile('./greet.txt',' Hello Ahtasham',{ flag : 'a' }, (err)=>{
                                    if(err){
                                         console.log(err)                   [  Flag  :  ' a '  property will append the content with the previous one ]
                                      }else{                                                      [ a  for append ]
                                         console.log('File Written')
                                       }
                           })


               ******* NOTE  ::::::  READ operation is slower than WRITE operation . So some consecutive read or write opertaion 

                                               are arranged together then READ operation will executed last .

             
*************************************************** FS  PROMISE MODULE **********************************************************

            const fs=require('node:fs/promises')

            console.log('First')
            fs.readFile('./file.txt','utf-8')
                      .then(data=>console.log(data))   [  If promise is resolved successfully , then it will lead to the next line and print it ]
                      
                     .catch(err=>console.log(err))  [  Promise is not resolved successfully , then it will be rejected . ]

            console.log('Second')

          OUTPUT ::::: 

                              First
                              Second
                              Hello Viewers ! Welcome to the session of NODE . JS   [  As it is a Asynchronous task , it will allow the next
                                                                                                                           operation execute and don't block them ]

         IF WE  DO IT WITH ASYNC AWAIT FUNCTION ::::   [  Work same as before ]

             const fs=require('node:fs/promises')

               async function readFile(){
                   try{
                         const data=await fs.readFile('./file.txt','utf-8')
                         console.log(data)
                  }catch(err){
                        console.log(err)
                    }
           }

                      ******* Recommended to use  Promise based File System over Callback File System .


********************************************************* STREAMS ******************************************************************

       ****** How  the FS  Module uses STREAMS to  READ snd WRITE data ::::: 

                const fs=require('node:fs')

               const readableStream=fs.createReadStream('./file.txt',{   [  Take the file content in this variable with a mathod having
                      encoding:'utf-8',                                                                path and options args ]
                      highWaterMark : 2    [  Default data passing rate is 64 But here WE changed THE BITS or CHUNK size to 2 bits ]
             
                   })

               const writeableStream=fs.createWriteStream('./file2.txt')           [  The read file will be written in this pathed file ]

               readableStream.on('data',(chunk)=>{       [ As  we know that STREAM inherits the EVENT Emitter classes methods so 
                        console.log(chunk)                               we can listen this event by ON and see the how many BITS or CHUNK
                        writeableStream.write(chunk)            pass from FILE . TXT to FILE2 . TXT ]
                 })


              OUTPUT ::::::    and At the same time file2.txt is written with the content if file.txt

                           He
                           ll
                            o
                           Br
                           ot
                           he
                           rs
                             !
                           !

              ********* TYPES  of  STREAM ::::: 

                          READABLE Streams from which data can be read .  [ Ex : Reading from a file as Readable Streams ]

                          WRITABLE stream to which we can write data .       [ Ex : Writting to a file as Writable Streams ]

                          DUPLEX  Streams that are both Readable and Writable . [ SOCKETS as a Duplex Stream ]

                          TRANSFORM Stream that can modify or transform the data as it is written and read .

                           [  File Compression where we can write compressed data and read de-compressed data to and from a file as

                              a Transform Stream ]


*********************************************************** PIPES *********************************************************************

         ****** MAKES  A  Direct  Connection from  ReadableStream to  WriteableStream 

            Ex :::: 

                      const fs=require('node:fs')

                      const zlib = require( ' node : zlib ' )    [ Provides a ZIPPED File facility and  Has a Built in Transform Stream ]

                      const glib=zlib.createGzip( )  [  Take the method to transform the file as a zipped file ] 

                      const readableStream=fs.createReadStream('./file.txt',{
                                  encoding:'utf-8',
                                  highWaterMark:2
                             })

                     const writeableStream=fs.createWriteStream('./file2.txt')

                     readableStream.pipe(writeableStream)    [  Set the destination file where contents be written in PIPE Method ]

                                                                                     [ However destination Stream be Readable , Duplex or Transform Stream ]

                     readableStream.pipe( glib ).pipe ( fs.createWriteableStream( './file.txt.gz ' )    

                   [  Here the readable file will be written in a ZIPPED File ( Transformed in first pipe ) and then it will be saved with

                        the written Content in the Zipped file ( Transformed in second Pipe ) ]


****************************************************** HTTP  MODULE **************************************************************

       ******  What happens when we Type a URL in a web BROWSER ::::: 

                   Computers are connected with internet are Called Client or Servers .

                   Clients are internet connected devices such as computers or mobiles along with web-accessing softwares like WEB

                   Browsers .

                                                                         **** CLIENT - SERVER  MODEL ****

                                     CLIENT  -->>>>>>        Request of a web page / app / sites to       <<<<<<-- SERVER 

                                                  [  Send  an HTTP  Request and Receive a HTTP Response sent by the server ]

                CLIENT  --<<<<<<<    Receives a Copy of a web page / app / sites as a Response to be displayed <<<<<-- SERVER
              
             
         ******* How the request made by CLIENT and the Requested data sent to the CLIENT by SERVER :::::       
         
                   HTTP  Defines  the data format for both CLIENT and SERVER to speak to each other .

             ******* HTTP and NODE . JS  Collaboration :::::: 

                     ***** We can create a WEB SERVER  using NODE . JS .
 
                      ***** NODE . JS has access to OS functionality like networking and has EVENT LOOP to run task Asynchronously

                              is perfect for creating web servers that can simultaneously handle large volume of requests . 

                              NODE SERVER  We create still has to respect the HTTP format .

                  ****** HTTP Module allows creation of  WEB SERVERS that can transfer data over HTTP . 

 
********************************************** CREATING A NODE SERVER *********************************************************

         ******** Creating a  NODE SERVER With HTTP Module  :::::

                 const http=require('node:http')     [  This  also  Extends the EVENT  EMITTER Class ]

                  const server =  http.createServer((req,res)=>{     [  This callback is a Request Listener. When a Request reaches the server                                                                                                     , This Call back function is executed ]
                                   res.writeHead(200 , { ' content-type ' : ' text/plain ' })
                                   res.end('Successfully sent a response !!!')        [ Req argument contains informations and content-type about                                                                                                                                                    the incoming request . ]
         
                                 [ IN res.end >>  We have to write Content for the RESPONSE which will be processed after getting a

                                                                               request  and WILL RENDER on the WEB Page .]
                          })

                          server.listen ( 3000 , ( ) => {            [  Set a Web port from where the server is running and the console will 
                                                                                                                                    show the below message ]
                                                    console.log( ' Server is running on port 3000 ' )

                                                  }  

                          [  FROM this port on WEB BROWSER URL/ REQ from HTTP.CreateServer( req, ..)  bar hit then it will show the                       
                              RESPONSE set on the  HTTP CreateServer ( .. , res ) ]


******************************************************* JSON  RESPONSE ************************************************************

        
            ****** How to Respond with JSON data :::::  BROWSER does not accept plain JS Object as a Response. So we have to 

                        Convert this Object into JSON format . 

                EXAMPLE ::::: 

                     const http=require('node:http')

                     const server=http.createServer((req,res)=>{
                       
                     const namePlate = {                          [  Made an Object and before Setting it as an RESPONSE we have to Stringify it
                                  firstName:'Ahtashamul',
                                  lastName:'Islam'                                              Using V8 Engine's Library  JSON . stringify ( namePlate ) ]
                             }
                     res.writeHead(200,{'content-type':' application/json '})
                     res.end(JSON.stringify(namePlate))
                })

              server.listen(3000,()=>{
             console.log('Server running on port 3000')
          })

                 ******* By doing this so FAR  WE  have JUST made our first API . Now the RESPONSE from that URL can be  used

                            to develop UI / FRONT END SIDE to the Client .


********************************************************* HTML RESPONSE *********************************************************

         ***** SENT a  HTML Response :::::: 

                      const http=require('node:http')

                      const fs = require ( ' node : fs ' )

                     const server=http.createServer((req,res)=>{
                    
                          res.writeHead(200,{'content-type':'text/html'})  [  SET  Content - type : text / html ]
   
                          res.end('<h1>Welcome to the Chrome</h1>')

                          // OR   [  If we want to send a HTML file as a response ]

                         const htmlFile=fs.readFileSync('./index.html','utf-8')
                         res.end(htmlFile)

                        // MAKE  IT  A STREAM FILE PERFORMANT ::::: 

                        fs.createReadStream( './index.html ' ).pipe(res)  [  Pipe this to the Response and it will be rendered as Web page ]

                        // ADDING  a RELATIVE PATH :::::: 

                       fs.createReadStream(__dirname+'/index.html').pipe(res)  [ Add a relative path on the HTML File ]
               
                   })

                    server.listen(3000,()=>{
                         console.log('Server running on port 3000')
                 })


**************************************************** HTML TEMPLATE **************************************************************

       ******** Create a  Index.html file :::: 

                     ............
                               <body>
                                     <h1>From index.html</h1>
                                     <h2>Hello {{name}} !!! Welcome to Node.js</h2>
                              </body>         [  This name will be Dynamically replaced by Node.js ]
                      </html>
          
                   ...............

        ******* SET  Dynamic HTML Template value in HTML File :::::: 


                       const http=require('node:http')
                       const fs=require('node:fs')

                       const server=http.createServer((req,res)=>{
  
                      res.writeHead(200,{'content-type':'text/html'})
                      const name='Ahtasham'                                             [  SET  THIS NAME and will Replaced by index.html file's name ]
                      let htmlFile=fs.readFileSync('./index.html','utf-8')
                      htmlFile=htmlFile.replace('{{name}}',name)            [  {{name}}  will be replaced by  name which is initialized here ]
                      res.end(htmlFile)          
    
                     })

                       server.listen(3000,()=>{
                      console.log('Server running on port 3000')
             })


********************************************************** HTTP ROUTING **********************************************************

         ******* How to set HTTP Routing page by page :::::: 

                    const http=require('node:http')
                    const fs=require('node:fs')

                    const server=http.createServer((req,res)=>{
                          const namePlate={
                                firstName:'Ahtashamul',
                                lastName:'Islam'
                             }
                                if(req.url==='/'){                                                         [  REQ . URL is a method which sent the requested url to 
                                    res.writeHead(200,{'content-type':'text/plain'})       NODE . JS and then we will Check it and RENDER
                                    res.end('Home page')                                                HTML page based on the URL ]
                            } else if(req.url==='/about'){
                                   res.writeHead(200,{'content-type':'text/plain'})
                                   res.end('About page')
                             }else if(req.url==='/api'){
                                   res.writeHead(200,{'content-type':'application/json'})
                                  res.end(JSON.stringify(namePlate))
                          }else{
                                  res.writeHead(404)
                                  res.end('Page not found')
                              }
                         })

                       server.listen(3000,()=>{
                       console.log('Server running on port 3000')
                   })


         ************  REQ . METHOD  and REQ . URL  can help us any kind of Routing and HTTP Module .

                             and  other  GET , POST , PUT , DELETE  comes with a Web frame work helps us to handle this .


****************************************************** WEB  FRAMEWORK **********************************************************


              ****** Creating a SERVER  using a WEB FRAME WORK  for  NODE . JS ::::::: 

                     ****** FRAMEWORK :::::: A framework simply abstracts lower level code allowing us to focus on the requirements 

                                                                than the code itself .

                                                                EX :::: React / Angular / Vue are framework / libraries help to build user interfaces without

                                                                           having to rely on the lower level DOM API in JS .

                                                 *******  There are frameworks to build web or mobile applications without having to rely on the 

                                                               HTTP Module in NODE . JS .

                                                               EX ::::: Express , Nest , Hapi , Koa , Sails etc . 

                                                ******* They build on top of the HTTP Module making it easier for us to implement all the features.

             
********************************************** INTERNALS OF  NODE . JS RUNTIME ************************************************

           ****** NODE . JS  Runtime has three Basic parts :::::

                     1 . JS  Library  

                    2 . C / C++ Features .

                    3 . Dependencies Like :::: V8 , libuv [ for handling Asynchronous Behaviors in NODE .JS ] , zlib , crypto , etc . 


************************************************ INTRODUCTION to LIBUV *********************************************************

        ****** Definition of  LIBUV ::::: is a cross platform open source library written in C language .

        ******* WHY  libuv :::::: Handles Asychronous  NON - BLOCKING  Operations in NODE . JS . Abstracts a Way of Dealing 
 
                                               with a OS .

        ****** HOW  libuv handles  Asynchronous operations ::::: Using  THREAD POOL and  EVENT  LOOP .

        

************************************************* LIBUV [ THREAD POOL ] *********************************************************
       
        ****** Understanding THREAD's POOL role of  handling Async Non Blocking Nature in NODE . JS ::::: 

                  ****** Create an Asynchronous READ File module in INDEX. JS :::: 

                             const fs=require('node:fs')

                             console.log('First')

                            fs.readFile('./file.txt','utf-8',(err,data)=>{
                                    console.log('File Contents')
                                 }
                                 )
                            console.log('Last')

                           OUTPUT ::::::  First 

                                                    File Contents 
 
                                                    Last .

                         ****** As  READING a FILE  is an Asynchronous task that's why it will let the execution process to the next forward 
                                   line . NODE . JS did this using libuv's THREAD POOL .

              ******** THREAD POOL  MECHANISM :::::: 

                           MAIN THREAD :::::  Whenever finds a time consuming or Asynchronous task it will offload this task to LIBUV.

                                  LIBUV ::::: LIBUV has a THREAD POOL which can run some of these time consuming tasks. When the task

                                                    is done the file contents are retrieved and the associated call back function can be called .

              ***********CREATING a NEW  CRYPTO  MODULE  [ Like FS module ] ::::::: 

                           IN index.js ::::: 

                              const crypto=require(' node:crypto ')           [  Crypto Module is a Module having Cryptographic Functions ]
                                                                                                         [ IT also use LIBUV Thread POOL for some it's methods ]
                             const start=Date.now()
                             crypto.pbkdf2Sync('password','salt',100000,512,'sha512')
                             crypto.pbkdf2Sync('password','salt',100000,512,'sha512')
                              console.log('Hash: ',Date.now()-start)                              [  pbkdf2  stands for  password based key derivation                                                                                                                                      function 2 is a popular  password HASH  Methods  to                                                                                                                             Store them  and it is CPU Intensive method.]
                      OUTPUT:::::  Hash : 2245 ms [ Indicates the time for Hashing dependent on the Machine ]        

                     [ DOUBLE Time Hash will take the 2 times of the single time hash. As it is handled by Asynchronous method
 
                       so the time is calculated after the completion of each tasks [ HASH ]  ]

   ******* NOTE  :::  Every Method in NODE . JS that has the SYNC  suffix always runs on the main thread and is blocking .


                ***** DO This Previous Code previously ::::: 

                          const  crypto = require ( ' node : crypto ' )

                           const  start = Date.now()

                           const MAX_CALLS = 1 / 2 / 3

                           for ( let i=0 ; i < MAX_CALLS ; i++ ) {
                                crypto.pbkdf2('password','salt',100000,512,'sha512'  , ( ) => {   [  WE Can use a Call back Function as an 
                                  console.log                                                                                   association ]
                           })
                          
                        OUTPUT ::::: 

                               Hash 2:  2043 ms   [  THREE Threads in Parallal ]
                               Hash 3:  2133 ms
                               Hash 1:  2183 ms      

                     [ THERE  are  the Asynchronous method's output of  PBKDF2 . Each  PBKDF2 runs in a seperate THREAD.

                       The THREADS are organized in LIBUV THREAD POOL ]

       ******* NOTE  ::::::  A few async methods like fs.readFile  and  crypto.pbkdf2 run on a seperate thread in libuv's thread pool.

                                      But they do run synchronously in their own thread but as far as the main thread concerned , it appears

                                     as if  the method is running Asynchronously . 


******************************************************* THREAD POOL SIZE ********************************************************

        ****** NUMBER  of THREADS in LIBUV's Thread Pool ::::: By DEFAULT  in LIBUV 's THREAD POOL size is 4 .

                  const crypto=require('node:crypto')

                 const MAX_CALLS=5
                 const start=Date.now()

                for(let i=0;i<MAX_CALLS;i++){
                        crypto.pbkdf2('password','salt',100000,512,'sha512',()=>{
                        console.log(`Hash ${i+1}: `,Date.now()-start)
                     })
                 } 
 
                OUTPUT  :::::: 

                                        Hash 1:  2315       [  FIRST  Four  take their individual THREAD  and the LAST one is executed as free ]
                                        Hash 3:  2331
                                        Hash 4:  2331
                                        Hash 2:  2344
                                        Hash 5:  3473


          ******** HOW TO CONTROL THE THREAD POOL SIZE IN LIBUV ::::: 

                          const crypto=require('node:crypto')

                         process.env.UV_THREADPOOL_SIZE=5    [  IT Will Increase the THREAD SIZE of  libuv ]

                        const MAX_CALLS=6
                        const start=Date.now()

                       for(let i=0;i<MAX_CALLS;i++){
                       crypto.pbkdf2('password','salt',100000,512,'sha512',()=>{
                       console.log(`Hash ${i+1}: `,Date.now()-start)
                    })
                 }

                  OUTPUT ::::: 

                            Hash 4: 2456            [ First 5 will be completed near about 2500 ms and the 6th one will take twice of the   
                            Hash 1:  2446               time because it is now out of the thread ]
                            Hash 3:  2446
                            Hash 2:  2467
                            Hash 5:  2855
                            Hash 6:  3928


             ****** So  By Increasing the THREAD POOL Size , we are able to improve the totalo time taken to run multiple calls of 

                       an Asynchronous Methods like PBKDf2()

            ******** RELATION Between CPU Cores and THREAD POOL SIZE :::::: 

                       IF  CPU Core and THREAD POOL are Equal then :::: 

                            Each thread takes one Core and SAME TIME to EXECUTE .

                      IF  CPU  Core  and  THREAD POOL  are not EQUAL but  the  THREAD POOL Size is twice of the CPU Core :::: 

                          Every  TWO threads will share one CPU Core . 

                          That means EACH THREAD TAKES twice of previous time to execute .

              ******NOTE :::: Increasing the thread POOL size can help us with performance but that is limited by the number of 

                                        available CPU  CORES .

         
****************************************************** NETWORK I / O **************************************************************

        ***** NOW  We  will take HTTP Request as our ASYNCHRONOUS TASKS :::::: 

                          const  https = require ( ' node : https ' )                                     [  Secured version HTTP request ]

                          const MAX_CALLS=12
                         const start=Date.now()

                        for(let i=0;i<MAX_CALLS;i++){
                         https.request('https://www.google.com',(res)=>{    [  Create a HTTP request with an URL and in CALLBack  we 
                                    res.on('data',()=>{})                                               will  get the RESPONSE and add event listener  ON ]
                                    res.on('end',()=>{
                                                     console.log(`Request ${i+1}: `,Date.now()-start)
                                          })
                                  })
                                    .end()           [  After  found the RESPONSE , end() method will terminate the REQUEST ]

                               }

                 OUTPUT :::::: 

                                   Request 3:  480         [   Here  all the HTTP response  arrived  at a average time inbetween 400 to 500 ms ]
                                   Request 4:  493
                                   Request 2:  497
                                   Request 5:  535
                                   Request 1:  539
                                   Request 6:  540


            ****** Although both  crypto.pbkdf2( ) and HTTP . Request ( ) are Asynchronous , HTTP . REQUEST method does not 

                      seem to use the THREAD POOL . As WE CAN SEE the Average time taken by each RESPONSE  from the previous

                     CODE .

            ******* HTTP Request does not seem to be affected by the number of CPU Cores each either .

            ******* HTTP Request is  a  NETWORK  INPUT / OUTPUT  operation not a  CPU bound operation . That's why it 

                        does not use the THREAD POOL . 
     
            ******* Libuv delegates the work to the OS kernel and whenever possible , it will poll [ list ] the kernel and see if the 

                       request has completed .

           ****** IN  NODE . JS Async methods are handled by LIBUV . They are handled in two different ways :::: 

                       1 . Native Async Mechanism  and  2 . THREAD POOL .

                           Whenever possible , Libuv will use native Async  Mechanisms in the OS so as to avoid blocking the main thread.

               ********* Since this is a part of KERNEL , there is different mechanism for each OS . We have epoll for LINUX , 

                              KQUEUE  for MAC OS and  IO Completion port for windows .

                              BUT  Relying on native async Mechanisms makes NODE . JS scalable as the only limitations is the OS Kernel . 

               ******* If there is no native support and the task is file  I/O  or CPU  Intensive , LIBUV uses the thread pool to avoid 

                          blocking the main thread .

                          Although the thread pool preserves asynchronousity with respect to NODE 's main thread , it can still become 

                         a bottleneck if all threads are busy . 

 
*********************************************************** EVENT  LOOP ***********************************************************

         ******* Code  Execution in NODE . JS ::::: 

                 :::: Google's  V8  Engine ::::                                                               ::::: LIBUV ::::: 

               Memory Heap    +   Call Stack                                                       Whenever Comes into a Async methods 
              
              Declare Var or          Whenever                                                       it will come into the LIBUV . Then it will run the task 

                Functions               Function Invoked                                          using native async Mechanism or if that is not possible

             Memory allcated       it will be poped Up                                       it will be done by THREAD POOL  of LIBUV .

            in the HEAP .             From the Stack .                                            ( ) => {  asynchronous tasks } 

                                             global ( ) >> Holds                                           After the time is being passed , then it will be sent back 

                                             the synchronous tasks.                                    to the CALL Stack  and EXECUTE it .

         ****** EVENT  LOOP ::::: It is a DESIGN Pattern and a part of LIBUV .  

                                                   A  design pattern that orchestrates or co-ordinates the execution of  Synchronous and 
                                                  Asynchronous  code in NODE . JS .
 
        ******* EVENT LOOP [ EXECUTION ORDER ] :::::: 

              ****** Top Priority ::::: User written Synchronous JS Code takes priority over Async Code that the runtime would like to 

                                                   execute . BUT Only after the CALL STACK is empty , the EVENT LOOP comes into PICTURE .

              ****** Secondary  Priority :::::

                                                  1 .  Any Callbacks in the micro task queues are executed . First , tasks in the nextTick queue 

                                                              and only then tasks in the Promise Queue . 

                                                  2 .  All Callbacks within the Timer Queue are executed . 

                                                   3 . Call Backs in the Micro Tasks Queues if present are executed . Again , first task is the 

                                                         nextTick Queue and then tasks in the Promise Queue .

                                                4 . All Call backs within the  I / O queue are executed .

                                                 5 . Call Backs in the Micro Tasks Queues if present are executed , nextTick Queue followed by the 
                                                     Promise Queue .
 
                                                 6 . All Call Backs in the check Queue are executed .

                                                 7 . Call Backs in the Micro Tasks Queues if present are executed . Again , first task is the 

                                                      nextTick Queue and then tasks in the Promise Queue .

                                                 8 . All Call Backs in the close queue are executed .

                                                 9 . For one final time in the same loop , the micro task queues are executed. nextTick queue 

                                                      followed by promise queue .

                      ******* If there are more CALLBACKS to be processed , the loop is kept alive for one more run and the same steps 

                                  are repeated . 
                  
                    ****** On the other hand , if all callbacks are executed and there is no more code to process , the event loop exists.

          ********  TWO  IMPORTANT  QUESTIONS ::::::: 

                    1 . Whenever Async tasks completes in LIBUV , at what point does NODE decide to run the associated CALL Back 

                        functions ? >>> Callbacks are executed only when the CALL Stack is empty . The Normal Flow of execution fill

                                                  not be interrupted to run a CALLBACK function .

                   2 . If two Async functions setTimeout and readFile complete at the same time , how does NODE decide which Call
 
                       back function to run first on the Call Stack ?  >>> Timer Callbacks are executed before I/O callbacks even if  both

                                                                                                         are ready at the exact same time.

                    
****************************************************** MICROTASK  QUEUE *********************************************************

         ****** EVENT  LOOP Comprises  6  QUEUES :::::: 

                    1 . nextTick Queue  

                    2 . Promise Queue 

                    3 . Timer Queue 

                    4 . I / O Queue 

                    5 . Check Queue  and 

                    6 . Close Queue .

             ****** ALL the  Queues take Callback functions and In Each LOOP Callback functions are DEQUEUD and Executed .

            ******* MICROTASK  QUEUES ::::: 

                 *** nextTick Queues ::::::: To initialize that queue we use a Callback functions . To show the callback functions we have 

                                                            to  follow the below rules >>> 

                                                      process.nextTick ( ( ) = > { 
                      
                                                                            console.log( ' This is process nextTick.1 ' ) 

                                                                        } 


                 *** Promise Queue ::::::: To initialize that queue we use a Callback functions . To show the callback functions we have 

                                                            to  follow the below rules >>> 

                                                      Promise.resolve( ).then ( ( ) = > { 
                      
                                                                            console.log( ' This is process nextTick.1 ' ) 

                                                                       } 


              **** EXAMPLE  of  nextTick and Promise :::::: 

                  **** 1st  Experiment :::::

                           console.log('Console.log 1')
                           process.nextTick(()=>{
                                       console.log('This is process.nextTick 1')
                                      })
                            console.log('Console.log 2')

                        OUTPUT :::::: 

                                   Console.log 1
                                   Console.log 2
                                   This is process.nextTick 1  [ It is Asynchronous task that is why Js will give highest priority to Synchronous

                                                                                 Task That's why the first two LINES of Code execured First ]


                           ****** Execution Cycle of the Code  Stated Above ::::: 

                                      First Line will go to the CallStacks global( ) functions  and Executed . 

                                      SECOND Line is a CallBack so it will be in MicroTask Queue .

                                      Third Line will go to the CallStacks global( ) functions  and Executed .                                 

                                      At Last , the SECOND line will be pushed to the Call Stack and be executed .


                  ***** 2nd Experiment ::::: 

                             Promise.resolve().then(()=>{
                                    console.log('This is Promise.resolve 1')
                                  })
                             process.nextTick(()=>{
                                    console.log('This is process.nextTick 1')
                                })

                            OUTPUT ::::: 

                                  This is process.nextTick 1     [ All  Callbacks in  nextTick  Queue are executed before Callbacks in Promise 
                                  This is Promise.resolve 1          Queue ]
                          
                                  [  IN CallStack  the Promise Call back is inserted first and the nextTick Callback is inserted last . According

                                     to  Stack DS LIFO order follows . So the nextTick will execute first and then the Promise Callback ]

                        ***** 2nd Experiment Extended ::::: 

                                process.nextTick(()=>{
                                    console.log('This is process.nextTick 1')
                                })
                                process.nextTick(()=>{
                                   console.log('This is process.nextTick 2')
                                process.nextTick(()=>{
                                   console.log('This is inner process.nextTick inside nextTick')
                               })
                             })
                               process.nextTick(()=>{
                                   console.log('This is process.nextTick 3')
                              })
                             
                              Promise.resolve().then(()=>{
                                    console.log('This is Promise.resolve 1')
                                 })
                              Promise.resolve().then(()=>{
                                    console.log('This is Promise.resolve 2')
                                    process.nextTick(()=>{
                                            console.log('This is inner nextTick inside Promise then block')
                                   })
                               })
                            Promise.resolve().then(()=>{
                                       console.log('This is Promise.resolve 3')
                               })
                         
                        OUPUT ::::::
                                  
                            This is process.nextTick 1
                            This is process.nextTick 2
                            This is process.nextTick 3
                            This is inner process.nextTick inside nextTick
                            This is Promise.resolve 1
                            This is Promise.resolve 2
                            This is Promise.resolve 3
                            This is inner nextTick inside Promise then block

             [  SO  It is clear  Callback of  nextTick always be executed first than  Promise.resolve( ).then( ) block's Callback ]

                 ******** The main reason of  using process.nextTick ( ) :::::: 

                           1 .  Generally  process.nextTick() is discouraged as it can cause the rest of the EVENT LOOP to Starve .

                          2 . If  Endlessly call process.nextTick ( ) the CONTROL will never make it past the Microstake Queue.

                          USE CASE of  nextTick ( ) :::: 

                            1 . To allow users to handle errors , cleanup any then unneeded resources , or perhaps try the request again

                                 before the EVENT Loop continues .

                            2 . To allow a Callback to run after the Call Stack has unwound but before the event loop Continues .



*********************************************************** TIMER  QUEUE **********************************************************

           
          ******* To  make a QUEUE of  Callback functions into Timer QUEUE , We can use setTimeout ( ) // OR // setInterval ( )

                ***** 1st Experiment ::::: 

                           setTimeout(()=>{
                                   console.log('This is setTimeout 1')
                                 })
                           setTimeout(()=>{
                                   console.log('This is setTimeout 2')
                                 })
                          setTimeout(()=>{
                                  console.log('This is setTimeout 3')
                                })
                           process.nextTick(()=>{
                                 console.log('This is process.nextTick 1')
                               })
                           process.nextTick(()=>{
                                 console.log('This is process.nextTick 2')
                           process.nextTick(()=>{
                                  console.log('This is inner process.nextTick inside nextTick')
                               })
                           })
                           process.nextTick(()=>{
                                  console.log('This is process.nextTick 3')
                            })
                           Promise.resolve().then(()=>{
                                   console.log('This is Promise.resolve 1')
                            })
                           Promise.resolve().then(()=>{
                                   console.log('This is Promise.resolve 2')
                                   process.nextTick(()=>{
                                           console.log('This is inner nextTick inside Promise then block')
                                   })
                             })
                            Promise.resolve().then(()=>{
                                      console.log('This is Promise.resolve 3')
                               })            


              OUTPUT  ::::::: 

                         This is process.nextTick 1
                         This is process.nextTick 2
                         This is process.nextTick 3
                         This is inner process.nextTick inside nextTick
                         This is Promise.resolve 1
                         This is Promise.resolve 2
                         This is Promise.resolve 3
                         This is inner nextTick inside Promise then block
                         This is setTimeout 1
                         This is setTimeout 2
                         This is setTimeout 3

              ******** CallBacks in the  MICROSTACK QUEUES  are executed before CallBacks in the TIMER  QUEUE 

                ****** 2nd Experiment ::::: 

                          setTimeout(()=>{
                               console.log('This is setTimeout 1')
                             },0)
                          setTimeout(()=>{
                              console.log('This is setTimeout 2')
                              process.nextTick(()=>{
                                 console.log('This is inner nextTick inside setTimeout')
                               })
                             },0)
                          setTimeout(()=>{
                                console.log('This is setTimeout 3')
                          },0)

              OUTPUT :::::: 

                       This is setTimeout 1         [  After each CallBack in Timer queue Invoked it will  Check MicroTask Queue if there 
                       This is setTimeout 2           is any process.nextTick( ) exist or not ]
                       This is inner nextTick inside setTimeout  [  The CallBack in the MICROTASK QUEUES  are executed in between 
                       This is setTimeout 3                                        the execution of CallBacks in the TIMER QUEUES ]

            
               *******  TIMER  QUEUE CallBacks are executed in FIFO Order .

              ******** TIMER  QUEUE  is not a  QUEUE . It is a  HEAP DS .


************************************************************* I / O QUEUE ***********************************************************

         ***** Most of the async Methods from the built-in modules queue the Callback functions in the I/O Queue.

                 ***** EX :::: fs.readFile( )

                *** 1st Experiment :::: 

                        const fs=require('node:fs')

                        fs.readFile(__filename,()=>{
                               console.log('This is readFile 1')
                         })

                       process.nextTick(()=>{
                             console.log('This is process.nextTick 1')
                         })
                       Promise.resolve().then(()=>{
                             console.log('This is Promise 1')
                        })

                 OUTPUT :::::: 

                     This is process.nextTick 1  
                     This is Promise 1
                     This is readFile 1                  [ I/O  Queue will be executed last ]

                ****** SO  Callbacks are in the MICROSTACK QUEUES  are executed before Callbacks in the I/O QUEUE .

                          MICROSTACK QUEUES [ Callbacks are executed first ] >>> Then come to the TIMER QUEUE >>> 

                            >>> I/O Request  QUEUE

                 
               ***** 2nd Experiment ::::: 

                        const fs=require('node:fs')

                        setTimeout(()=>{
                            console.log('This is setTimeout 1')
                           },0)

                       fs.readFile(__filename,()=>{
                            console.log('This is readFile 1')
                         })

              
                  OUTPUT ::::: 
          
                            This is setTimeout 1
                            This is readFile 1

                   //OR  This is readFile 1
                              This is setTimeout 1       [  Depends  Upon the DISC speed of  a particular Machine ]

                 ******* When  running  setTimeout( ) with delay 0ms and an I/O async method , the order of execution can never be 

                             guaranteed . **** Because :::: When set 0ms delay in setTimeout( ) at start of the EVENT LOOP , NODE .JS 

                                                           needs to figure out is 1ms setTimeout has elapsed or not . If there is no such setTimeout 

                                                           then it will move forward to the I/O QUEUE's readFile Callback. And the very next iteration

                                                           TIMER QUEUE setTimeout( ) will be Invoked .

                                                           BUT if the TIMER QUEUE is  busy or setTimeout ( ) is given 1.01 ms then it will be Executed

                                                           first and then it will move on to the I/O QUEUE and Executes readFile Callback . 

              ***** 3rd Experiment :::::: 

                        const fs=require('node:fs')

                       fs.readFile(__filename,()=>{
                                 console.log('This is readFile 1')
                              })

                      process.nextTick(()=>{
                                console.log('This is process.nextTick 1')
                         })
                      Promise.resolve().then(()=>{
                               console.log('This is Promise.resolve 1')
                           })
                      setTimeout(()=>{
                               console.log('This is setTimeout 1')
                      },1)


                     OUTPUT ::::: 

                          This is process.nextTick 1
                          This is Promise.resolve 1
                          This is setTimeout 1
                          This is readFile 1  

                       [  Execution Order :::: Microtask Queue >>> Promise Queue >>> Timer Queue >>> I/O Queue ]

               
************************************************************* I/O POLLING **********************************************************

               I / O  Polling  is  Working in Between the I/O QUEUE and CHECK QUEUE .

              ***** CHECK QUEUE ::::: 

                       SetImmediate ( ) method is used in the CHECK QUEUE . 

                    **** 1st Experiment ::::: 

                           const fs=require('node:fs')

                          fs.readFile(__filename,()=>{
                                  console.log('This is readFile 1')
                              })

                          process.nextTick(()=>{
                                 console.log('This is process.nextTick 1')
                              })
                          Promise.resolve().then(()=>{
                                 console.log('This is Promise.resolve 1')
                             })
                         setTimeout(()=>{
                                 console.log('This is setTimeout 1')
                             },1)
                          setImmediate(()=>{
                                   console.log('This is setImmediate 1')
                             },1)


               OUTPUT ::::: 

                     This is process.nextTick 1
                     This is Promise.resolve 1
                     This is setTimeout 1
                     This is setImmediate 1
                     This is readFile 1               [ It happens because this I/O Callback is not listed primarilly ( reading a file operation is not 
                                                                  completed ) and the I/O Polling will move forward to CHECK QUEUE and execute the  
                                                               setImmediate ( ) Callback . After that it will go to the I/O QUEUE and execute the readFile( )      
                                                                Callback .]

             ******* I/O  events are polled and callback functions are added to the I/O QUEUE only after the I/O is complete .

                         
********************************************************** CHECK QUEUE ***********************************************************

       ****** Scenario if  I/O Polling was Complete and A Callback in  I/O QUEUE did exist :::::: 

            ****** 1st Experiment ::::: 

                    const fs=require('node:fs')

                   fs.readFile(__filename,()=>{
                            console.log('This is readFile 1')
                            setImmediate(()=>{
                                  console.log('This is setImmediate 1')
                             },1)
                         })

                   process.nextTick(()=>{
                           console.log('This is process.nextTick 1')
                       })
                   Promise.resolve().then(()=>{
                           console.log('This is Promise.resolve 1')
                      })
                   setTimeout(()=>{
                          console.log('This is setTimeout 1')
                   },1)

               OUTPUT ::::: 

                    This is process.nextTick 1
                    This is Promise.resolve 1
                    This is setTimeout 1
                    This is readFile 1
                    This is setImmediate 1  

             ******** So it is Cleared that CHECK QUEUE CallBacks are executed after Microstack Queue Callbacks , Timer Queue 

                           CallBacks  and I/O Queue CallBacks are executed .

               ***** 2nd Experiment ::::: 

                      const fs=require('node:fs')

                      fs.readFile(__filename,()=>{
                                   console.log('This is readFile 1')
                      setImmediate(()=>{
                                   console.log('This is setImmediate inside readFile')
                             },1)
                      process.nextTick(()=>{
                                   console.log('This is process.nextTick inside readFile')
                              })
                      Promise.resolve().then(()=>{
                                  console.log('This is Promise.resolve inside readFile')
                             })
                        })

                      process.nextTick(()=>{
                                 console.log('This is process.nextTick 1')
                              })
                      Promise.resolve().then(()=>{
                                console.log('This is Promise.resolve 1')
                            })
                      setTimeout(()=>{
                               console.log('This is setTimeout 1')
                          },1)

                 OUTPUT ::::: 

                    This is process.nextTick 1
                    This is Promise.resolve 1
                    This is setTimeout 1
                    This is readFile 1
                    This is process.nextTick inside readFile
                    This is Promise.resolve inside readFile
                    This is setImmediate inside readFile

              ******* MICROTASK QUEUE  Callbacks are executed After I/O Callbacks and Before CHECK QUEUE Callbacks .

               ***** 3rd Experiment ::::: 

                        const fs=require('node:fs')

                        setImmediate(()=>{
                              console.log('This is setImmediate 1')
                            })
                        setImmediate(()=>{
                              console.log('This is setImmediate 2')
                              process.nextTick(()=>{
                                     console.log('This is process.nextTick inside setImmediate')
                                  })
                              Promise.resolve().then(()=>{
                                     console.log('This is Promise.resolve inside setImmediate')
                                 })
                            })
                        setImmediate(()=>{
                                 console.log('This is setImmediate 3')
                         })

                OUTPUT ::::: 

                      This is setImmediate 1
                      This is setImmediate 2
                      This is process.nextTick inside setImmediate    [  Whenever Found MICROTASK QUEUE it will be given priority and
                      This is Promise.resolve inside setImmediate              executed First ]
                      This is setImmediate 3

                ***** 4th Experiment ::::: 

                       setTimeout(()=>{
                              console.log('This is setTimeout 1')
                      },0)
                       setImmediate(()=>{
                              console.log('This is setImmediate 1')
                       },1)

                 OUTPUT :::::: 

                     This is setTimeout 1
                     This is setImmediate 1  // OR 

                      This is setImmediate 1
                      This is setTimeout 1

                  ****** While runnig setTimeout with delay 0ms and setImmediate method , the order of execution can never be 

                             guaranteed . 

 
************************************************************ CLOSE QUEUE *********************************************************

        ***** 1st Experiment ::::: 

                  const fs=require('node:fs')

                   const readableStream=fs.createReadStream(__filename)
                   readableStream.close()

                  readableStream.on('close',()=>{
                           console.log('This is readableStream close event callback')
                   })

                   setTimeout(()=>{
                           console.log('This is setTimeout 1')
                     },0)
                    setImmediate(()=>{
                            console.log('This is setImmediate 1')
                   },1)
                 Promise.resolve().then(()=>{
                           console.log('This is Promise.resolve 1 ')
                   })
                 process.nextTick(()=>{
                           console.log('This is process.nextTick 1')
                 })
    

             OUTPUT ::::::: 

                    This is process.nextTick 1
                    This is Promise.resolve 1
                    This is setTimeout 1
                    This is setImmediate 1
                    This is readableStream close event callback  [  CLOSE  QUEUE will be executed last ]

            ******** CLOSE  QUEUE's  Callbacks are executed after all other queues Callbacks in a given iteration of an EVENT LOOP.

            ******* NOTE :::::::

                       EVENT LOOP is a C program that coordinates the execution of synchronous and asynchronous code in NODE.JS.

                       Coordinates in SIX different queues >>>> nextTick , Promise , Timer , I/O , Check , Close .
    
                     The order of execution ::::

                    process.nextTick >>> Promise >>> setTimeout/setInterval >>> I/O [ async tasks ] >>> setImmediate ( ) >>>Close

                    ***** nextTick and Promise Queues are executed in between each queue and also in between each Callback 
 
                             execution in the Timer and Check queues .

 
************************************************ NPM [ Node Package Module ]******************************************************

         ***** NPM :::::: 

                          1 . It is the world's largest Software Library . 

                          2 . It is a Software Package Manager .

                   ****** NPM is a Largest Software Library :::::  a library or a registry which contains code  packages written by various

                                                                                                developers . 

                                                                                               a large public database of JS code that developers from all over the 
     
                                                                                               world can use to share and borrow code . 

                           ****** If you author a ' Code Package ' , you can publish it to the npm registry for others to use .

                  *******NPM is a Software Package Manager ::::: Developers publish and consume code Packages .

                   ******* Other package managers are PNPM and YARN .

                 ***** NPM is the default package manager of  NODE .JS  .  But Now it evolved as a package manager for the JS 

                          programming language .

                  ***** WHY  NPM :::::: 

                           When building enterprice scale applications , we often need to rely on code written by other developers , we

                            need NPM .

******************************************************** PACKAGE . JSON ************************************************************

         ****** Package . json :::: is a npm configuration file . It is a JSON File that typically lives in the root directory of your 

                                                 package and holds various metadata relevant to the package .

         ****** Why Package . json ::::: is the central place to configure and describe how to interact and run your package .

                                                          It is primarily used by the npm CLI .

       ****** Creating a JSON File with a default value using CLI ::::::  npm init --yes 

                       {
                          "name": "greet-module",
                          "version": "1.0.0",
                          "description": "",
                          "main": "index.js",
                          "scripts": {
                                            "test": "echo \"Error: no test specified\" && exit 1"
                                      },
                         "keywords": [],
                         "author": "",
                        "license": "ISC"
                     }
                     

******************************************************* INSTALLING  PACKAGES ****************************************************

         ***** Intalling Packages in a particular Folder :::::: 

                ******* CLI Command :::::  npm install package_name 

                  It will create a dependency property in package.json file and also create a  NODE Module having the package in 

                  that folder . 


***************************************************** DEPENDENCIES ***************************************************************


          ******** Packages we use in NODE . JS  is basically  MODULE. 

          ******* Whenever a new package is installed the DEPENDENCIES field of  package.json is populated.

           ****** If any developer clones our projects startup files , they will not have the NPM folder .

  
********************************************************** VERSIONING *************************************************************

         ****** To install a latest version package in our application :::::: 

                                 npm install package_name@2.0.0 

             but if we don't mention any version >>> npm install package_name  [ It will install the latest version as well ]

         ***** Why version has 3 digits to represent :::: NPM adopted semantic versioning process. 

                              SemVer ::::: Known as Semantic Versioning is widely adopted versioning system. A simple set of rules and 
 
                                                  requirements that dictate how version numbers are assigned and increamented .

                                                 It is crucial to keep a semantic and historical track of changes .

                                                 Version number and the way they change convey meaning about the underlying code and what has

                                                 been modified from one version to the next .

                  ****** Pattern of a version ::::::   X . Y . Z :::: x is for Major Version , y is for Minor version , z is for Patch .

               ******* Versioning Rules :::::: 1 . When you fix a bug and the code stays backwards - compatible you increament the patch

                                                               version . EX ::::  1 . 1 . 1  to  1 . 1 . 2   [  After Fixixng bug patch updated ]

                              ******* 2 . When you add new functionality but the code stays backwards - compatible , you incre-

                                                                     ment th minor version . You also reset the patch version to zero . 

                                                                    EX ::::: 1 . 1 . 1  to  1 . 2 . 0 [ After adding a new functionality ]

                            ******** 3 . When you make changes and the code is no longer backwords compatible , you increment the major 

                                               version . EX ::::: 1 . 1 . 1 to  2 . 0 . 0   [  Increment the Major  Version and reset the Minor and Patch 

                                                                                                             Version ]

              ******** Semantic Versioning always  start with 0 . 1 . 0 [ 0 . Y . Z ]

                            A major version is used for initial development 0 . 1 . 0 

                           When the code is production - ready , Increment to version 1 . 0 . 0 

 
************************************************ GLOBAL PACKAGES ****************************************************************

         ***** For NODE . JS a very popular Global package is NODE MON .

                  ***** NODE MON :::::: Simple Monitor Script for use during development of  a NODE . JS App . Its a package intended

                                                        to be used from CLI .

                                                       Command ::::: npm  install  -g  nodemon  [ Installation Command ]

                                                                               npm uninstall -g nodemon  [ Uninstallation Command ]

      
********************************************************* NPM  SCRIPTS *************************************************************

        ***** An NPM Script is a conventional way to bundle common commands for use in a project . 

        ***** Typically entered in the command line in order to do something with the application .

        ****** Stored in the project's Package.json file , giving access to everyone who has access to the Codebase . 

        ****** Ensuring that everyone is using the same command with the same options .

        ****** Common use cases for npm scripts include building your PROJECTS , starting a DEV SERVER , compiling CSS , Linting , 

                   Minifying etc . 

        ****** Are executed by the general Command ::::::  npm run < Script_Name > 

        ****** EXAMPLE :::::: 

                      In our package . json File ::::::  Change the script and write the Command as like stated above .

                                 ............

                                 "scripts": {
                                                 "start": "node index.js"
                                            },

                                ...........

                            ****** Run the script :::::  npm run start [ it will run in the console ] // OR  npm start 

                                     npm run start

                                     > greet-module@1.0.0 start
                                     > node index.js

                                     Hello Ahtasham , Welcome to NODE.JS , Let's get started

                             [  This will be the real scenario after the execution of the Script ]


************************************************ PUBLISHING AN NPM PACKAGE ***************************************************

         ***** Publishing a Package to the NPM Registry :::::  First create an Account in npmjs.com

                             Creating a package folder named >> shobuj-cp

                          In shobuj-cp folder :::::  npm init --yes [ it will create a package.json file ]

                               Create a File index.js in shobuj-cp folder ::::::

                                                 function greet(name){
                                                 console.log(`Hello ${name} , Welcome to Node.js`)
                                                 }
                                                greet('Ahtasham')
                                               module.exports=greet

                   Now in Terminal :::::: 

                                  > npm adduser  ahtashamulislam [  Added to npmjs.com ]
 
                                 > npm publish [ Existing in the shobuj-cp folder , the function will be published in upper account ]

               ****** Using this Published package in a project ::::: 

                             **** Create a Folder ::::  verfiy-pack 

              **** In verfiy-pack folder directory ::::::  npm init --yes [ create a package.json ]

                                                                              npm i shobuj-cp [ download the package ]

                                                    After  that  command a package-lock.json and node_modules are created.

                               in it's package.json ::::: 

                                                       { 
                                                           " dependencies " : " shobuj-cp " 
                                                       }

               ****** Create index.js file :
                                                             const greet=require('shobuj-cp')  [ Import the greet function from downloaded package ]
                                                                            
                                                             greet('Batman')

                               OUTPUT ::::::  Hello Batman , Welcome to Node.js 

                              
**************************************** BUILDING  CLI  TOOLS [ With NODE and NPM]*******************************************

           ******* CLI or  Command Line Interface is basically a program that can be run from the terminal .

                ****** Popular CLI :::::  NPM  and  Git [ Version Control System ]

                 ***** Create a Folder  named  shobuj-cli :::::  npm init --yes [  Create a  package.json file ]

                         ***** Create a File named index.js ::::: 

                                     #!/usr/bin/env node    [  it is HASH BANG  and NODE is used as a interpreter ]
                                        
                                     console.log('Ahtashamul CLI')

                 ****** Push a property named   bin in package.json file ::::: 

                                     "bin":{
                                                   "Ahtasham-Shobuj":"index.js"   [  Now Ahtasham-Shobuj  will be the Command line and it can 
                                            }                                                                execute index.js file ]

                ******* In terminal [ shobuj-cli directory ]::::: 

                              > Ahtasham-Shobuj 

                              > Ahtashamul CLI  [  It is written in index.js ]


********************************************************* CLI  OPTIONS *************************************************************

         ********  Passing argument from CLI ::::: 

                         In index.js from  shobuj-cli folder ::::::

                                const yargs=require('yargs')              [ Download this local third party package ]
                                const {argv}=yargs(process.argv)

                                const printFiveMoves = async (pokemonName)=>{
                                const response = await fetch(
                                             `https://pokeapi.co/api/v2/pokemon/${pokemonName}`
                                          )
                                const pokemon=await response.json()
                                const moves=pokemon.moves.map(({move})=>move.name)
                                                   console.log(moves.slice(0,5))
                                              }
                             printFiveMoves(argv.pokemon)   [  Now it will be allow an argument with an assignment pokemonName ]
                                                             [ pokemon  will pass the argument to the Async function ]

                      ****** In  Terminal ::::: 

                                      > Ahtasham-Shobuj --pokemon=charmander     [  In above Code we set args.pokemon ]

                          OUTPUT ::::: 

                                      [
                                        'mega-punch',
                                        'fire-punch',
                                        'thunder-punch',
                                        'scratch',
                                        'swords-dance'
                                      ]      



************************************************ INTERACTIVE  CLI  TOOLS ********************************************************

        
       ***** Installing a Package for making CLI Interactive :::::   npm  install  inquirer@8.2.5  [ Version 9 or above only support ES
                                                                                                                                                          Modules ]
        ****** IN index.js File of shobuj-cli Folder :::::: 

                       const inquirer=require('inquirer')

                          const printFiveMoves = async (pokemonName)=>{
                          const response = await fetch(
                                                                        `https://pokeapi.co/api/v2/pokemon/${pokemonName}`
                                                               )
                          const pokemon=await response.json()
                          const moves=pokemon.moves.map(({move})=>move.name)
                          console.log(moves.slice(0,5))
                       }

                         const prompt=inquirer.createPromptModule()               [ First  Create a Prompt Module ]

                         prompt([                                              [  It receives an Object for input ]
                                             {
                                               type:'input',              [  User will get an input option ]
                                               name:'pokemon',       [ User input pass this under >> this  pokemon name  ]
                                               message:'Enter a pokemon name to display first 5 moves' [ This will be displayed in the terminal ]
                                             },
                                   ]).then((answers)=>{                                     [  It will return a Promise having the above values ]
                                               const pokemon=answers.pokemon   [ User's given pokemon name will be stored in pokemon var ]
                                               printFiveMoves(pokemon)               [ Finally this function will be invoked by this pokemon ]
                                   })

                  
                    OUTPUT ::::::

                      > Ahtasham-Shobuj
                                  
                        ? Enter a pokemon name to display first 5 moves  mew [ mew is the pokemon name ] 
                                  
                       [ 'pound', 'mega-punch', 'pay-day', 'fire-punch', 'ice-punch' ] [ Final result after invoking the printFiveMoves() ]

                        
******************************************************** MISCELLINEOUS************************************************************

********************************************************* CLUSTER MODULE ********************************************************

     ****** As we know NODE is single threaded and no matter how many cores you have , NODE only uses a single core of CPU .

               This is OK for I/O operations , But in case of CPU intensive operations , application might struggle from a performance

              point of view . To solve this issue , CLUSTER Module comes into the scenario . 

              ****** CLUSTER MODULE :::: enables the creation of child Processes ( also called Workers ) that run simultaneously .

                                                                 All created Workers share the same SERVER Port .


             ******* Creating a File named after no-cluster.js :::::: 

                         const http=require('node:http')

                         const server=http.createServer((req,res)=>{
                          if(req.url==='/'){
                                res.writeHead(200,{'Content-Type':'text/plain'})
                                res.end('Home Page')
                           }else if(req.url='/slow-page'){
                                for(let i=0; i<600000000; i++){}          //Simulated CPU Task.
                                res.writeHead(200 , {'Content-Type':'text/plain'})
                                res.end('Slow Page')
                          }
                      })
                        server.listen(8000,()=>{
                             console.log('Server is running successfully on port 8000')
                        })

                OUTPUT in the Browser :::::: If we refresh the two different tabs localhost:8000 and localhost:8000/slow-page  ,  then 

                                                                after checking that the time taken for loading for both is almost same . It is happened

                                                                because of a long for loop iteration . And we don't use any CLUSTER here .

                 
               ****** Understanding CLUSTER module ::::::: 

                          index.js >>> CLUSTER MASTER  and it it will run the Workers [ worker 1  and  worker 2 ]

               ****** MASTER is only incharge of the Workers . Actions are >>> Starting, Stopping , Restarting  etc but does not 

                          execute the application code itself . Not in-charge of handling incoming requests etc.

               ****** WORKERS are incharge of handling incomin requests , reading files etc and each WORKER gets its own EVENT

                         loop memory and V8 instances . In doing so , we are able to share the Work LOAD across different instances 

                         without having to block incoming requests .

             ******** Distinguish between MASTER and WORKER :::::: 

                          const cluster=require('node:cluster')
                          const http=require('node:http')

                          if(cluster.isMaster){
                                       console.log(`This is Master Class ${process.pid} running`)
                             
                                  cluster.fork()                      [ Create TWO WORKERS INSTANCES ]
                                  cluster.fork()
                            }else{
                                     console.log(`This is workers class ${process.pid} starting`)
                                     const server=http.createServer((req,res)=>{
                              if(req.url==='/'){                                                                   [  Here TWO WORKERS take over these two 
                                     res.writeHead(200,{'Content-Type':'text/plain'})            REQUESTS and HANDLE them individually ]
                                     res.end('Home Page')
                                  }else if(req.url='/slow-page'){
                                        for(let i=0; i<600000000; i++){}                                   //Simulated CPU Task.
                                     res.writeHead(200 , {'Content-Type':'text/plain'})
                                     res.end('Slow Page')
                                 }
                             })
                                server.listen(8000,()=>{
                                     console.log('Server is running successfully on port 8000')
                                 })
                           }

               ******* Without  creating WORKERS the only MASTER class exists and handled the server request as they are written .

               ******* When two WORKERS take over the requests individually then the requests run with their own rendered 

                            elements without effecting one another .

                *******BUT We can not create a large numbers of WORKERS by invoking cluster.fork( ) method ?

                            ******  We should only create as many WORKERS as there are CPU cores on the machine the app is running . 

                           ******* Creating more WORKERS than there are logical cores on the computer it can cause an overhead as the 

                                       system will have to schedule all the created workers with fewer number of cores .

                                       EX :::: If I have 10 logical cores on my PC, then I can create maximum 10 WORKERS , creating more will be

                                                  hurting rather than helping .

                  ****** To Know the CPU Cores :::::: 

                                const OS=require('node:os')   [  Import the built-in module named OS ]

                                console.log(OS.cpus().length)   [  Method  cpus( ) invoking ]

                                OUTPUT :::::: 4 [ for my PC ]

                ****** Easiest way of CREATING  CLUSTERS and WORKERS ::::::: 

              >  npm install -g pm2   [  Its a npm package which provides all the facilities to work with a Cluster ]

               >  pm2 start no-cluster.js -i 0 / 2 [  The last 0 will be given and it will automatically create the optimum number of 

                                                                    Cluster WORKERS according to the REQUESTS // any number can mention  ]

                         OUTPUT ::::::   [ As my PC have 4 Cores so it will create 4 Workers to handle requests on browsers ]

                            id  name                mode           status     cpu       memory   
                        
                         0   no-cluster          cluster   0     online     0%        34.2mb   
                         1   no-cluster          cluster   0     online     0%        29.6mb   
                         2   no-cluster          cluster   0     online     0%        31.6mb   
                         3   no-cluster          cluster   0     online     0%        31.3mb   
                        

              > pm2 stop no-cluster.js   [  It will stop the pm2 and close all the Clusters into one Master Cluster ]


************************************************* WORKERS THREADS MODULE ***************************************************

     ****** Workers Threads Module :::::: Enables us the use of threads that execute JS in parallel . 

     ******* Code executed in Worker Thread runs in a seperate Child Process , preventing it from blocking your main application .

     ******* The CLUSTER Module can be used to run multiple instances of Node.Js that can be distribute workloads . 

     ******* But  WORKER_THREAD Module allows running multiple application threads within a single NODE .JS Instance . 

     ******* Use Case of WORKER_THREAD Module :::::: 

                     When process isolation is not needed , that is , no seperate instances of V8 , Event Loop , and Memory are needed 

                      We should use WORKER _ THREAD Module .

                 ******* Create main-thread.js File ::::: 

                              const http=require('node:http')
                              const {Worker}=require('node:worker_threads')         [  Take the Worker Class from worker_threads module ]

                             const server=http.createServer((req,res)=>{
                              if(req.url==='/'){
                                        res.writeHead(200,{'Content-Type':'text/plain'})
                                        res.end('Home Page')
                                    }else if(req.url='/slow-page'){
                                       
                                       const worker = new Worker('./worker_thread.js')    [  Create a  Worker Object to handle the task which 
                                        
                                              worker.on('message',(j)=>{                                                  has a possibility of blocking the page ]
                                                             [  Come this j from worker_thread.js file ]
                                                      res.writeHead(200 , {'Content-Type':'text/plain'})
                                                      res.end(`Slow Page ${j}`)
                                                })
                                          }
                                    })
                                server.listen(8000,()=>{
                                         console.log('Server is running successfully on port 8000')
                                  })

                ******* The File worker_thread.js from where the Value j is exported :::::: 

                               const {parentPort}=require('node:worker_threads')

                                        let j=0
                                         for(let i=0; i<600000000; i++){
                                                         j++
                                                    } 

                                       parentPort.postMessage(j)  [  Sent this value in worker object's Callback argument ]


**************************************************** DEPLOYING NODE. JS APP *****************************************************


























































































                      






























































































                             




















                   
                 



















        

               












































                      

     


















                  

                         




















































































































                            


































                       

















































              























                                                                                                                  

































               

                       

                    














































              
















































       


























































                      





















































        




































                      






















                  















































                      














































                                    





























































































                                         

                 

            












































 


































































                                                                               

















     
























































                                                             























































          
















    





































































































                                                               
                 



                                                  
























































































































































































